@page "/game"
@using Ludo.Blazor.Components.Components.Game
@using Ludo.Game.Controller
@using Ludo.Game.Enums
@using Ludo.Game.Interfaces
@using Ludo.Game.Models.Board
@using Ludo.Game.Models.Dice
@using Ludo.Game.Models.Piece
@using Ludo.Game.Models.Player
@using Ludo.Game.Utils.BoardGenerate
@inject NavigationManager Nav
@inject GameSessionService Session

<div class="game-page">
    <main class="game-main">
        <PlayerIndicator Player="currentPlayer" />
        <section class="board-section">
            <BoardView Board="currentGame.Board" PiecesPostion="currentGame.PiecePositions"
                       ClickablePieces="clickablePieces" OnPieceClicked="OnPieceClicked" OnPieceHover="OnPieceHover"
                       OnPieceHoverOut="ClearPreview" PreviewTile="previewTile" />
        </section>
        <DiceIndicator DiceValue="lastDiceValue" CanRoll="canRollDice" IsRolling="isRolling" OnRoll="RollDice" />
    </main>
    @* <button @onclick="MoveAllPieceToGoal">ended</button> *@
</div>

@code {
    GameController currentGame = null!;
    IPlayer currentPlayer => currentGame.GetCurrentPlayer();
    Random random = new Random();
    Tile? previewTile;
    HashSet<Piece> clickablePieces = new();

    int lastDiceValue = 1;
    public bool canRollDice { get; private set; } = true;
    public bool isRolling { get; private set; }

    protected override void OnInitialized()
    {
        @* currentGame = new GameController(StandardBoard.GenerateBoard(), new Dice(6), new List<IPlayer>{new Player("player 1",
Color.Red), new Player("player 2", Color.Green)}); *@
        if (Session.Game == null)
        {
            Nav.NavigateTo("/", replace: true);
            return;
        }

        currentGame = Session.Game!;
    }

    async Task RollDice()
    {
        isRolling = true;
        canRollDice = false;
        StateHasChanged();

        for (int i = 0; i < 10; i++)
        {
            lastDiceValue = random.Next(1, currentGame.Dice.Sides + 1);
            StateHasChanged();
            await Task.Delay(80);
        }

        lastDiceValue = currentGame.RollDice();
        clickablePieces = currentGame.GetMoveablePieces(currentPlayer).ToHashSet();

        if (clickablePieces.Count == 0)
        {
            EndTurn();
        }

        isRolling = false;
        StateHasChanged();
    }

    async void OnPieceClicked(Piece piece)
    {
        if (!clickablePieces.Contains(piece))
            return;

        clickablePieces.Clear();

        currentGame.MovePiece(currentPlayer, piece);

        if (currentGame.IsTurnFinished())
        {
            EndTurn();
        }
        else
        {
            canRollDice = true;
        }

        ClearPreview();
        StateHasChanged();
    }

    void OnPieceHover(Piece piece)
    {
        if (!clickablePieces.Contains(piece)) return;

        Tile? currentTile = currentGame.GetPieceTile(piece);
        List<Tile> path = currentGame.Board.ColorPaths[piece.Color];

        if (currentTile == null || currentTile.Zone == Zone.Home)
        {
            previewTile = lastDiceValue == currentGame.Dice.Sides ? path[0] : null;
            return;
        }

        int index = path.IndexOf(currentTile);
        int target = index + lastDiceValue;

        previewTile = target < path.Count ? path[target] : null;
    }

    void ClearPreview()
    {
        previewTile = null;
    }

    void EndTurn()
    {
        if (currentGame.IsGameOver())
        {
            Session.GetWinner();
            Nav.NavigateTo("/winner");
        }

        ClearPreview();
        clickablePieces.Clear();
        canRollDice = true;
        currentGame.NextTurn();
    }

    void MoveAllPieceToGoal()
    {
        currentGame.MoveAllPieceToGoal(currentPlayer);
        EndTurn();
    }
}